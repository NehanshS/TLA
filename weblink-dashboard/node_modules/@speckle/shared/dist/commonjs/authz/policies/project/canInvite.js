"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.canInviteToProjectPolicy = void 0;
const result_1 = require("true-myth/result");
const authErrors_js_1 = require("../../domain/authErrors.js");
const server_js_1 = require("../../fragments/server.js");
const constants_js_1 = require("../../../core/constants.js");
const projects_js_1 = require("../../fragments/projects.js");
const canInviteToProjectPolicy = (loaders) => async ({ userId, projectId }) => {
    const ensuredServerRole = await (0, server_js_1.ensureMinimumServerRoleFragment)(loaders)({
        userId,
        role: constants_js_1.Roles.Server.User
    });
    if (ensuredServerRole.isErr)
        return (0, result_1.err)(ensuredServerRole.error);
    const ensuredProjectRole = await (0, projects_js_1.ensureImplicitProjectMemberWithWriteAccessFragment)(loaders)({
        userId: userId,
        projectId,
        role: constants_js_1.Roles.Stream.Owner
    });
    if (ensuredProjectRole.isErr)
        return (0, result_1.err)(ensuredProjectRole.error);
    const env = await loaders.getEnv();
    const project = await loaders.getProject({ projectId });
    if (project && !project.workspaceId && env.FF_PERSONAL_PROJECTS_LIMITS_ENABLED) {
        // Prevent inviting collaborators to personal projects
        return (0, result_1.err)(new authErrors_js_1.PersonalProjectsLimitedError({
            message: 'No new collaborators can be added to personal projects'
        }));
    }
    return (0, result_1.ok)();
};
exports.canInviteToProjectPolicy = canInviteToProjectPolicy;
//# sourceMappingURL=canInvite.js.map