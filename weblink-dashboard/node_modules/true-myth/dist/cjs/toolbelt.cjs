"use strict";
/**
  Tools for working easily with `Maybe` and `Result` *together*... but which do
  not *require* you to use both. If they were in the `true-myth/maybe` or
  `true-myth/result` modules, then importing either would always include the
  other. While that is not usually a concern with bundlers, it *is* an issue
  when using dynamic imports or otherwise doing runtime resolution in a browser
  or similar environment.

  The flip side of that is: importing from *this* module *does* require access
  to both `Maybe` and `Result` modules.

  @module
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromResult = exports.toOkOrElseErr = exports.toOkOrErr = exports.transposeMaybe = exports.fromMaybe = exports.toMaybe = exports.transposeResult = void 0;
const result_js_1 = require("./result.cjs");
const maybe_js_1 = require("./maybe.cjs");
const utils_js_1 = require("./-private/utils.cjs");
/**
  Transposes a {@linkcode Result} of a {@linkcode Maybe} into a `Maybe` of a
  `Result`.

  | Input         | Output         |
  | ------------- | -------------- |
  | `Ok(Just(T))` | `Just(Ok(T))`  |
  | `Err(E)`      | `Just(Err(E))` |
  | `Ok(Nothing)` | `Nothing`      |

  @param result a `Result<Maybe<T>, E>` to transform to a `Maybe<Result<T, E>>`.
 */
function transposeResult(result) {
    return result.match({
        Ok: (maybe) => maybe.match({
            Just: (v) => maybe_js_1.default.just(result_js_1.default.ok(v)),
            Nothing: () => maybe_js_1.default.nothing(),
        }),
        Err: (e) => maybe_js_1.default.just(result_js_1.default.err(e)),
    });
}
exports.transposeResult = transposeResult;
/**
  Convert a {@linkcode Result} to a {@linkcode Maybe}.

  The converted type will be {@linkcode Maybe~Just Just} if the `Result` is
  {@linkcode Result~Ok Ok} or {@linkcode Maybe~Nothing Nothing} if the `Result`
  is {@linkcode Result~Err Err}; the wrapped error value will be discarded.

  @param result The `Result` to convert to a `Maybe`
  @returns      `Just` the value in `result` if it is `Ok`; otherwise `Nothing`
 */
function toMaybe(result) {
    return result.isOk ? maybe_js_1.default.just(result.value) : maybe_js_1.default.nothing();
}
exports.toMaybe = toMaybe;
function fromMaybe(errValue, maybe) {
    const op = (m) => (m.isJust ? result_js_1.default.ok(m.value) : result_js_1.default.err(errValue));
    return (0, utils_js_1.curry1)(op, maybe);
}
exports.fromMaybe = fromMaybe;
/**
  Transposes a {@linkcode Maybe} of a {@linkcode Result} into a `Result` of a
  `Maybe`.

  | Input          | Output        |
  | -------------- | ------------- |
  | `Just(Ok(T))`  | `Ok(Just(T))` |
  | `Just(Err(E))` | `Err(E)`      |
  | `Nothing`      | `Ok(Nothing)` |

  @param maybe a `Maybe<Result<T, E>>` to transform to a `Result<Maybe<T>, E>>`.
 */
function transposeMaybe(maybe) {
    return maybe.match({
        Just: (result) => result.match({
            Ok: (v) => result_js_1.default.ok(maybe_js_1.default.just(v)),
            Err: (e) => result_js_1.default.err(e),
        }),
        Nothing: () => result_js_1.default.ok(maybe_js_1.default.nothing()),
    });
}
exports.transposeMaybe = transposeMaybe;
function toOkOrErr(error, maybe) {
    const op = (m) => (m.isJust ? result_js_1.default.ok(m.value) : result_js_1.default.err(error));
    return maybe !== undefined ? op(maybe) : op;
}
exports.toOkOrErr = toOkOrErr;
function toOkOrElseErr(elseFn, maybe) {
    const op = (m) => (m.isJust ? result_js_1.default.ok(m.value) : result_js_1.default.err(elseFn()));
    return (0, utils_js_1.curry1)(op, maybe);
}
exports.toOkOrElseErr = toOkOrElseErr;
/**
  Construct a {@linkcode Maybe~Maybe Maybe<T>} from a
  {@linkcode Result~Result Result<T, E>}.

  If the `Result` is an `Ok`, wrap its value in `Just`. If the `Result` is an
  `Err`, throw away the wrapped `E` and transform to a
  {@linkcode Maybe~Nothing Nothing}.

  @template T  The type of the value wrapped in a `Result.Ok` and in the `Just`
                of the resulting `Maybe`.
  @param result The `Result` to construct a `Maybe` from.
  @returns      `Just` if `result` was `Ok` or `Nothing` if it was `Err`.
 */
function fromResult(result) {
    return result.isOk ? maybe_js_1.default.just(result.value) : maybe_js_1.default.nothing();
}
exports.fromResult = fromResult;
//# sourceMappingURL=toolbelt.cjs.map