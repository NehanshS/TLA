"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.canCreateProjectCommentPolicy = void 0;
const result_1 = require("true-myth/result");
const server_js_1 = require("../../../fragments/server.js");
const authErrors_js_1 = require("../../../domain/authErrors.js");
const projects_js_1 = require("../../../fragments/projects.js");
const constants_js_1 = require("../../../../core/constants.js");
const types_js_1 = require("../../../domain/projects/types.js");
const canCreateProjectCommentPolicy = (loaders) => async ({ userId, projectId }) => {
    // Ensure server access
    const ensuredServerRole = await (0, server_js_1.ensureMinimumServerRoleFragment)(loaders)({
        userId
    });
    if (ensuredServerRole.isErr) {
        return (0, result_1.err)(ensuredServerRole.error);
    }
    // Check if public commenting enabled
    const project = await loaders.getProject({ projectId });
    if (!project)
        return (0, result_1.err)(new authErrors_js_1.ProjectNotFoundError());
    const allowPublicCommenting = project.visibility === types_js_1.ProjectVisibility.Public && project.allowPublicComments;
    if (allowPublicCommenting)
        return (0, result_1.ok)();
    // Not public, ensure proper project write access
    const ensuredWriteAccess = await (0, projects_js_1.ensureImplicitProjectMemberWithWriteAccessFragment)(loaders)({
        userId,
        projectId,
        role: constants_js_1.Roles.Stream.Reviewer
    });
    if (ensuredWriteAccess.isErr) {
        return (0, result_1.err)(ensuredWriteAccess.error);
    }
    return (0, result_1.ok)();
};
exports.canCreateProjectCommentPolicy = canCreateProjectCommentPolicy;
//# sourceMappingURL=canCreate.js.map