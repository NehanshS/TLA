"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.canLeaveProjectPolicy = void 0;
const result_1 = require("true-myth/result");
const constants_js_1 = require("../../../core/constants.js");
const authErrors_js_1 = require("../../domain/authErrors.js");
const server_js_1 = require("../../fragments/server.js");
const projects_js_1 = require("../../fragments/projects.js");
const canLeaveProjectPolicy = (loaders) => async ({ userId, projectId }) => {
    const ensuredServerRole = await (0, server_js_1.ensureMinimumServerRoleFragment)(loaders)({
        userId
    });
    if (ensuredServerRole.isErr) {
        return (0, result_1.err)(ensuredServerRole.error);
    }
    const ensuredWorkspaceAccess = await (0, projects_js_1.ensureProjectWorkspaceAccessFragment)(loaders)({
        userId: userId,
        projectId
    });
    if (ensuredWorkspaceAccess.isErr) {
        return (0, result_1.err)(ensuredWorkspaceAccess.error);
    }
    // Ensure user is not the last owner
    const projectRole = await loaders.getProjectRole({ projectId, userId: userId });
    if (!projectRole) {
        return (0, result_1.err)(new authErrors_js_1.ProjectNoAccessError('You must be a project member to leave'));
    }
    if (projectRole !== constants_js_1.Roles.Stream.Owner) {
        return (0, result_1.ok)();
    }
    const ownerCounts = await loaders.getProjectRoleCounts({
        projectId,
        role: constants_js_1.Roles.Stream.Owner
    });
    if (ownerCounts < 2) {
        return (0, result_1.err)(new authErrors_js_1.ProjectLastOwnerError('As the last owner of the project, you cannot leave'));
    }
    return (0, result_1.ok)();
};
exports.canLeaveProjectPolicy = canLeaveProjectPolicy;
//# sourceMappingURL=canLeave.js.map